var __awaiter=this&&this.__awaiter||function(e,c,u,f){return new(u=u||Promise)(function(t,n){function o(e){try{a(f.next(e))}catch(e){n(e)}}function r(e){try{a(f.throw(e))}catch(e){n(e)}}function a(e){var n;e.done?t(e.value):((n=e.value)instanceof u?n:new u(function(e){e(n)})).then(o,r)}a((f=f.apply(e,c||[])).next())})};function decode(t,o){return __awaiter(this,void 0,void 0,function*(){const e=new AudioContext({sampleRate:o}),n=e.decodeAudioData(t);return n.finally(()=>e.close())})}function normalize(e){const t=e[0];if(t.some(e=>1<e||e<-1)){var o=t.length;let n=0;for(let e=0;e<o;e++){var r=Math.abs(t[e]);r>n&&(n=r)}for(const a of e)for(let e=0;e<o;e++)a[e]/=n}return e}function createBuffer(n,e){return normalize(n="number"==typeof n[0]?[n]:n),{duration:e,length:n[0].length,sampleRate:n[0].length/e,numberOfChannels:n.length,getChannelData:e=>null==n?void 0:n[e],copyFromChannel:AudioBuffer.prototype.copyFromChannel,copyToChannel:AudioBuffer.prototype.copyToChannel}}const Decoder={decode:decode,createBuffer:createBuffer};export default Decoder;