<!DOCTYPE html>
<html>
<head>
    <title>Web Audio API Process and Save Audio</title>
</head>
<body>
    <input type="file" id="upload" accept="audio/*">
    <button id="process">Process and Save</button>
    <script>
        document.getElementById('process').addEventListener('click', async () => {
            const fileInput = document.getElementById('upload');
            if (!fileInput.files.length) {
                alert('Please upload an audio file.');
                return;
            }

            const file = fileInput.files[0];
            const arrayBuffer = await file.arrayBuffer();
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

            // Set up OfflineAudioContext
            const offlineContext = new OfflineAudioContext(
                audioBuffer.numberOfChannels,
                audioBuffer.length,
                audioBuffer.sampleRate
            );

            const bufferSource = offlineContext.createBufferSource();
            bufferSource.buffer = audioBuffer;

            const delay = offlineContext.createDelay();
            delay.delayTime.value = 0.5; // 0.5 seconds delay

            // Connect nodes properly
            bufferSource.connect(delay);
            delay.connect(offlineContext.destination);

            // Start rendering
            bufferSource.start();
            const renderedBuffer = await offlineContext.startRendering();

            // Convert the rendered audio to a blob and download it
            const wavData = audioBufferToWav(renderedBuffer);
            const blob = new Blob([wavData], { type: 'audio/wav' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'processed-audio.wav';
            a.click();
        });

        // Helper function to convert AudioBuffer to WAV format
        function audioBufferToWav(buffer) {
            const numOfChan = buffer.numberOfChannels,
                  length = buffer.length * numOfChan * 2 + 44,
                  bufferArray = new Uint8Array(length),                  
                  channels = [],
                  sampleRate = buffer.sampleRate,
                  bitsPerSample = 16,
                  pos = 0;
            var view = new DataView(bufferArray.buffer);

            function writeString(str) {
                for (let i = 0; i < str.length; i++) {
                    view.setUint8(pos++, str.charCodeAt(i));
                }
            }

            function floatTo16BitPCM(output, offset, input) {
                for (let i = 0; i < input.length; i++, offset += 2) {
                    const s = Math.max(-1, Math.min(1, input[i]));
                    output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
                }
            }

            writeString('RIFF');
            view.setUint32(4, length - 8, true);
            writeString('WAVE');
            writeString('fmt ');
            view.setUint32(16, 16, true); // Subchunk1Size (16 for PCM)
            view.setUint16(20, 1, true); // AudioFormat (1 for PCM)
            view.setUint16(22, numOfChan, true); // Number of Channels
            view.setUint32(24, sampleRate, true); // Sample Rate
            view.setUint32(28, sampleRate * numOfChan * bitsPerSample / 8, true); // Byte Rate
            view.setUint16(32, numOfChan * bitsPerSample / 8, true); // Block Align
            view.setUint16(34, bitsPerSample, true); // Bits Per Sample
            writeString('data');
            view.setUint32(40, length - 44, true); // Subchunk2Size (data chunk size)

            for (let i = 0; i < numOfChan; i++) {
                channels.push(buffer.getChannelData(i));
            }

            let offset = 44; // Start after the WAV header
            for (let i = 0; i < channels[0].length; i++) {
                for (let j = 0; j < numOfChan; j++) {
                    floatTo16BitPCM(bufferArray, offset, channels[j]);
                    offset += 2;
                }
            }

            return bufferArray;
        }
    </script>
</body>
</html>
